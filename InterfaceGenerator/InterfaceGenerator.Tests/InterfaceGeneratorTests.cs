using System;
using System.Collections.Immutable;
using System.Linq;
using System.Threading.Tasks;
using InterfaceGenerator.Tests.Utils;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Xunit;

namespace InterfaceGenerator.Tests;

public class InterfaceGeneratorTests
{
    [Fact]
    public Task GeneratesInterfaceForSimpleClass()
    {
        const string source = @"
using Generators;

namespace TestNamespace;

[GenerateInterface]
public class SimpleClass
{
    public string Name { get; set; }
    public int Age { get; }
    private string PrivateProperty { get; set; }
}";

        const string expected = @"// <auto-generated/>

namespace TestNamespace;

#nullable enable
public partial interface ISimpleClass
{
    string Name { get; set; }
    int Age { get; }
}
";

        return TestHelper.Verify(source, expected);
    }

    [Fact]
    public Task GeneratesInterfaceWithMethods()
    {
        const string source = @"
using Generators;

namespace TestNamespace;

[GenerateInterface]
public class ClassWithMethods
{
    public void DoSomething() { }
    public string GetName() => ""Test"";
    public async Task<int> CalculateAsync(int x, string y) => await Task.FromResult(42);
    private void PrivateMethod() { }
}";

        const string expected = @"namespace TestNamespace;

#nullable enable
public partial interface IClassWithMethods
{
    void DoSomething();
    string GetName();
    global::System.Threading.Tasks.Task<int> CalculateAsync(int x, string y);
}";

        return TestHelper.Verify(source, expected);
    }

    [Fact]
    public Task GeneratesInterfaceForGenericClass()
    {
        const string source = @"
using Generators;
using System.Collections.Generic;

namespace TestNamespace;

[GenerateInterface]
public class GenericClass<T> where T : class, new()
{
    public T Value { get; set; }
    public List<T> Items { get; }
    public void Process<TInput>(TInput input) where TInput : struct { }
}";

        const string expected = @"namespace TestNamespace;

#nullable enable
public partial interface IGenericClass<T>
    where T : class, new()
{
    T Value { get; set; }
    global::System.Collections.Generic.List<T> Items { get; }
    void Process<TInput>(TInput input) where TInput : struct;
}";

        return TestHelper.Verify(source, expected);
    }

    [Fact]
    public Task GeneratesInterfaceWithNullableReferences()
    {
        const string source = @"
using Generators;

namespace TestNamespace;

[GenerateInterface]
public class NullableClass
{
    public string? NullableName { get; set; }
    public int? NullableAge { get; }
    public void Process(string? input, int? count) { }
}";

        const string expected = @"// <auto-generated />

namespace TestNamespace;

#nullable enable
public partial interface INullableClass
{
    string? NullableName { get; set; }
    int? NullableAge { get; }
    void Process(string? input, int? count);
}";

        return TestHelper.Verify(source, expected);
    }

    [Fact]
    public Task GeneratesInterfaceWithIgnoredMembers()
    {
        const string source = @"
using Generators;

namespace TestNamespace;

[GenerateInterface]
public class ClassWithIgnoredMembers
{
    public string Name { get; set; }
    
    [GenerateIgnore]
    public int IgnoredProperty { get; set; }
    
    public void DoSomething() { }
    
    [GenerateIgnore]
    public void IgnoredMethod() { }
}";

        const string expected = @"namespace TestNamespace;

#nullable enable
public partial interface IClassWithIgnoredMembers
{
    string Name { get; set; }
    void DoSomething();
}";

        return TestHelper.Verify(source, expected);
    }
}

public static class TestHelper
{
    public static Task Verify(string source, string expected)
    {
        SyntaxTree syntaxTree = CSharpSyntaxTree.ParseText(source);
        CSharpCompilation compilation = CSharpCompilation.Create(
            "Tests",
            [syntaxTree],
            References);

        InterfaceIncrementalGenerator generator = new();
        GeneratorDriver driver = CSharpGeneratorDriver.Create(generator);

        driver = driver.RunGenerators(compilation);

        CSharpCompilation outputCompilation = compilation.AddSyntaxTrees(CSharpSyntaxTree.ParseText(expected));

        // Run the generator and get the output
        driver.RunGeneratorsAndUpdateCompilation(compilation, out Compilation updatedCompilation, out ImmutableArray<Diagnostic> diagnostics);

        // Get the generated source
        SyntaxTree[] newSources = updatedCompilation.SyntaxTrees
            .Where(t => t != syntaxTree)
            .ToArray();

        // Assert.Single(newSources);
        // Assert contains 2 sources
        Assert.Equal(2, newSources.Length);
        SyntaxTree? nonAttributeSource = newSources.Where(s => !s.FilePath.Contains("GenerateInterfaceAttributes")).FirstOrDefault();
        Assert.NotNull(nonAttributeSource);
        string generatedSource = nonAttributeSource.ToString();
        // string generatedSource = newSources[0].ToString();

        // Compare with expected
        Assert.Equal(expected.ReplaceLineEndings(), generatedSource.ReplaceLineEndings());

        return Task.CompletedTask;
    }

    private static readonly ImmutableArray<MetadataReference> References = ImmutableArray.Create<MetadataReference>(
        MetadataReference.CreateFromFile(typeof(object).Assembly.Location),
        MetadataReference.CreateFromFile(typeof(Task).Assembly.Location),
        MetadataReference.CreateFromFile(typeof(System.Runtime.CompilerServices.CompilerGeneratedAttribute).Assembly.Location),
        MetadataReference.CreateFromFile(typeof(System.Collections.Generic.List<>).Assembly.Location)
    );
}