using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace InterfaceGenerator;

[Generator(LanguageNames.CSharp)]
public class InterfaceGenerator : IIncrementalGenerator
{
    private const string Namespace = "InterfaceGenerator.Attributes";
    private const string GenerateInterfaceAttributeName = "GenerateInterfaceAttribute";
    private const string GenerateIgnoreAttributeName = "GenerateIgnoreAttribute";

    // language=cs
    private const string AttributeSourceCode = $@"// <auto-generated/>
using System;

#nullable enable

namespace {Namespace}
{{
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface, Inherited = false, AllowMultiple = false)]
    public sealed class {GenerateInterfaceAttributeName} : System.Attribute
    {{
        public Type? TargetType {{ get; }}

        public {GenerateInterfaceAttributeName}()
        {{
        }}

        public {GenerateInterfaceAttributeName}(Type targetType)
        {{
            TargetType = targetType;
        }}
    }}

    [AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Method, Inherited = false, AllowMultiple = false)]
    public sealed class {GenerateIgnoreAttributeName} : Attribute
    {{
    }}
}}";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
#if LAUNCH_DEBUGGER
        System.Diagnostics.Debugger.Launch();
#endif

        // Add the marker attribute to the compilation.
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            "GenerateInterfaceAttributes.g.cs",
            SourceText.From(AttributeSourceCode, Encoding.UTF8)));

        IncrementalValuesProvider<(SyntaxNode Node, SemanticModel SemanticModel)> declarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (s, _) => IsSyntaxTargetForGeneration(s),
                static (ctx, _) => (ctx.Node, ctx.SemanticModel))
            .WithTrackingName(TrackingNames.InitialExtraction)
            .Where(static t => t.Node is not null && t.SemanticModel is not null)
            .WithTrackingName(TrackingNames.RemovingNulls);

        IncrementalValueProvider<(Compilation Compilation, ImmutableArray<(SyntaxNode Node, SemanticModel SemanticModel)> Targets)> compilationAndTargets =
            context.CompilationProvider.Combine(declarations.Collect());

        context.RegisterSourceOutput(compilationAndTargets, static (spc, source) => Execute(source.Compilation, source.Targets, spc));
    }

    private static bool IsSyntaxTargetForGeneration(SyntaxNode node) => node is TypeDeclarationSyntax { AttributeLists.Count: > 0 };

    private static void Execute(
        Compilation compilation,
        ImmutableArray<(SyntaxNode Node, SemanticModel SemanticModel)> targets,
        SourceProductionContext context)
    {
        if (targets.IsDefaultOrEmpty)
        {
            return;
        }

        foreach ((SyntaxNode node, SemanticModel semanticModel) in targets)
        {
            TypeDeclarationSyntax typeDeclaration = (TypeDeclarationSyntax)node;
            ISymbol? symbol = semanticModel.GetDeclaredSymbol(typeDeclaration);

            if (symbol is not INamedTypeSymbol declaredSymbol)
            {
                continue;
            }

            AttributeData? attributeData = declaredSymbol.GetAttributes()
                .FirstOrDefault(ad => ad.AttributeClass?.Name == GenerateInterfaceAttributeName);

            if (attributeData == null)
            {
                continue;
            }

            INamedTypeSymbol? targetType = null;

            // If this is an interface declaration with a target type specified
            if (declaredSymbol.TypeKind == TypeKind.Interface && attributeData.ConstructorArguments.Length > 0)
            {
                if (attributeData.ConstructorArguments[0].Value is INamedTypeSymbol specifiedType)
                {
                    targetType = specifiedType;
                }
            }
            else if (declaredSymbol.TypeKind == TypeKind.Class)
            {
                targetType = declaredSymbol;
            }

            if (targetType == null)
            {
                continue;
            }

            StringBuilder sourceBuilder = new();
            sourceBuilder.Clear();
            GenerateInterface(typeDeclaration, sourceBuilder, targetType, semanticModel);

            string typeName = typeDeclaration.Identifier.Text;
            if (!typeName.StartsWith("I"))
            {
                typeName = "I" + typeName;
            }

            SourceText sourceText = SourceText.From(sourceBuilder.ToString(), Encoding.UTF8);
            context.AddSource($"{typeName}.g.cs", sourceText);
        }
    }

    private static void GenerateInterface(TypeDeclarationSyntax typeDeclaration, StringBuilder sourceBuilder, INamedTypeSymbol classSymbol, SemanticModel semanticModel)
    {
        string accessibility = classSymbol.DeclaredAccessibility == Accessibility.Public
            ? "public"
            : "internal";
        string className = typeDeclaration.Identifier.Text;
        sourceBuilder.AppendLine("// <auto-generated/>");
        sourceBuilder.AppendLine();
        sourceBuilder.AppendLine($"namespace {GetNamespace(typeDeclaration)};");
        sourceBuilder.AppendLine();
        sourceBuilder.AppendLine("#nullable enable");

        string genericParameters = "";
        if (classSymbol.TypeParameters.Length > 0)
        {
            genericParameters = $"<{string.Join(", ", classSymbol.TypeParameters.Select(tp => tp.Name))}>";
        }

        sourceBuilder.AppendLine($"{accessibility} partial interface I{className}{genericParameters}");

        // Add type parameter constraints if any
        foreach (ITypeParameterSymbol typeParam in classSymbol.TypeParameters)
        {
            string constraints = GetTypeParameterConstraints(typeParam);
            if (!string.IsNullOrEmpty(constraints))
            {
                sourceBuilder.AppendLine($"    {constraints}");
            }
        }

        sourceBuilder.AppendLine("{");

        HashSet<string> processedMembers = new();

        foreach (ISymbol member in classSymbol.GetMembers())
        {
            if (member.GetAttributes().Any(ad => ad.AttributeClass?.Name == "GenerateInterfaceAttribute"))
            {
                continue;
            }

            if (member.IsImplicitlyDeclared    ||
                member.Name.StartsWith("get_") ||
                member.Name.StartsWith("set_") ||
                member.Name.StartsWith("add_") ||
                member.Name.StartsWith("remove_"))
            {
                continue;
            }

            if (member.IsStatic)
            {
                continue;
            }

            if (member.DeclaredAccessibility != Accessibility.Public)
            {
                if (member is IPropertySymbol property)
                {
                    if ((property.GetMethod == null || property.GetMethod.DeclaredAccessibility != Accessibility.Public) &&
                        (property.SetMethod == null || property.SetMethod.DeclaredAccessibility != Accessibility.Public))
                    {
                        continue;
                    }
                }
                else
                {
                    continue;
                }
            }

            string memberSignature = GetMemberSignature(member);
            if (!processedMembers.Add(memberSignature))
            {
                continue;
            }

            if (member is IPropertySymbol property2)
            {
                string typeWithGlobal = GetGlobalType(semanticModel, property2.Type, className);
                bool hasPublicGetter = property2.GetMethod?.DeclaredAccessibility == Accessibility.Public;
                bool hasPublicSetter = property2.SetMethod?.DeclaredAccessibility == Accessibility.Public;

                string accessors = "";
                if (hasPublicGetter)
                {
                    accessors += "get; ";
                }

                if (hasPublicSetter)
                {
                    accessors += "set; ";
                }

                sourceBuilder.AppendLine($"    {typeWithGlobal} {property2.Name} {{ {accessors}}}");
            }
            else if (member is IMethodSymbol method)
            {
                string typeParameters = "";
                string constraints = "";

                if (method.TypeParameters.Length > 0)
                {
                    typeParameters = $"<{string.Join(", ", method.TypeParameters.Select(tp => tp.Name))}>";

                    IEnumerable<string> typeConstraints = method.TypeParameters
                        .Select(GetTypeParameterConstraints)
                        .Where(c => !string.IsNullOrEmpty(c));

                    if (typeConstraints.Any())
                    {
                        constraints = " " + string.Join(" ", typeConstraints);
                    }
                }

                string returnType = GetGlobalType(semanticModel, method.ReturnType, className);
                string parameters = string.Join(", ",
                    method.Parameters.Select(p =>
                    {
                        string paramType = GetGlobalType(semanticModel, p.Type, className);
                        string paramName = GetSafeParameterName(p.Name);

                        ImmutableArray<AttributeData> attributes = p.GetAttributes();
                        AttributeData? maybeNullWhenAttr = attributes.FirstOrDefault(a =>
                            a.AttributeClass?.Name is "MaybeNullWhenAttribute" or "MaybeNullWhen");

                        string attributeStr = "";
                        if (maybeNullWhenAttr is not null)
                        {
                            object? value = maybeNullWhenAttr.ConstructorArguments.FirstOrDefault().Value;
                            string valueStr = value?.ToString().ToLower() ?? "false";
                            attributeStr = $"[global::System.Diagnostics.CodeAnalysis.MaybeNullWhen({valueStr})] ";
                        }

                        string defaultValue = p.HasExplicitDefaultValue
                            ? $" = {p.ExplicitDefaultValue}"
                            : "";

                        string modifiers = p.RefKind switch
                        {
                            RefKind.Out => "out",
                            RefKind.Ref => "ref",
                            RefKind.In  => "in",
                            _           => ""
                        };

                        return $"{attributeStr}{modifiers} {paramType} {paramName}{defaultValue}".Trim();
                    }));

                sourceBuilder.AppendLine($"    {returnType} {method.Name}{typeParameters}({parameters}){constraints};");
            }
        }

        sourceBuilder.AppendLine("}");
    }

    private static string GetTypeParameterConstraints(ITypeParameterSymbol typeParameter)
    {
        List<string> constraints = new();

        if (typeParameter.HasReferenceTypeConstraint)
        {
            constraints.Add("class");
        }
        else if (typeParameter.HasValueTypeConstraint)
        {
            constraints.Add("struct");
        }

        if (typeParameter.HasNotNullConstraint)
        {
            constraints.Add("notnull");
        }

        if (typeParameter.HasUnmanagedTypeConstraint)
        {
            constraints.Add("unmanaged");
        }

        foreach (ITypeSymbol constraintType in typeParameter.ConstraintTypes)
        {
            constraints.Add(constraintType.ToDisplayString());
        }

        if (typeParameter.HasConstructorConstraint)
        {
            constraints.Add("new()");
        }

        if (constraints.Count == 0)
        {
            return "";
        }

        return $"where {typeParameter.Name} : {string.Join(", ", constraints)}";
    }

    private static string GetSafeParameterName(string paramName)
        => Utils.Keywords.Contains(paramName)
            ? "@" + paramName
            : paramName;

    private static string GetGlobalType(SemanticModel semanticModel, ITypeSymbol typeSymbol, string className)
    {
        if (typeSymbol is ITypeParameterSymbol typeParameter)
        {
            return typeParameter.Name;
        }

        // ! TODO this is a hack to handle ISyncEvent in ArenaEntityBase
        if (typeSymbol.Name == "ISyncEvent" && typeSymbol.ContainingNamespace.IsGlobalNamespace)
        {
            return "global::sliced.Entities.ArenaEntityBase.ISyncEvent";
        }

        if (typeSymbol is IArrayTypeSymbol arrayType)
        {
            string elementType = GetGlobalType(semanticModel, arrayType.ElementType, className);
            if (arrayType.Rank == 1)
            {
                return $"{elementType}[]";
            }

            return $"{elementType}[{new string(',', arrayType.Rank - 1)}]";
        }

        if (typeSymbol is INamedTypeSymbol { IsTupleType: true } tupleType)
        {
            string tupleElements = string.Join(", ",
                tupleType.TupleElements.Select(e =>
                {
                    string elementType = GetGlobalType(semanticModel, e.Type, className);
                    return string.IsNullOrEmpty(e.Name)
                        ? elementType
                        : $"{elementType} {e.Name}";
                }));
            return $"({tupleElements})";
        }

        if (typeSymbol is INamedTypeSymbol { IsGenericType: true } genericType)
        {
            string typeArgs = string.Join(", ", genericType.TypeArguments.Select(t => GetGlobalType(semanticModel, t, className)));

            if (genericType.ConstructedFrom.SpecialType == SpecialType.System_Nullable_T)
            {
                return $"{typeArgs}?";
            }

            string baseName = genericType.ConstructedFrom.ToDisplayString(new SymbolDisplayFormat(
                typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,
                genericsOptions: SymbolDisplayGenericsOptions.None));

            return $"global::{baseName}<{typeArgs}>";
        }

        if (typeSymbol.ContainingType is not null)
        {
            List<string> typePathParts = new();
            INamedTypeSymbol? currentType = typeSymbol.ContainingType;

            typePathParts.Add(typeSymbol.Name);

            while (currentType is not null)
            {
                typePathParts.Add(currentType.Name);
                currentType = currentType.ContainingType;
            }

            string namespacePart = typeSymbol.ContainingNamespace?.IsGlobalNamespace == false
                ? $"global::{typeSymbol.ContainingNamespace}"
                : "global";

            typePathParts.Reverse();
            string typePath = string.Join(".", typePathParts);

            return $"{namespacePart}.{typePath}";
        }

        string globalType = typeSymbol.SpecialType switch
        {
            SpecialType.System_Boolean => "bool",
            SpecialType.System_String  => "string",
            SpecialType.System_Int32   => "int",
            SpecialType.System_Single  => "float",
            SpecialType.System_Double  => "double",
            SpecialType.System_Void    => "void",
            SpecialType.System_Object  => "object",
            SpecialType.System_UInt64  => "ulong",
            _                          => $"global::{typeSymbol.ContainingNamespace}.{typeSymbol.Name}"
        };

        if (typeSymbol.NullableAnnotation == NullableAnnotation.Annotated)
        {
            // Only add ? for reference types and value types that aren't already Nullable<T>
            bool isAlreadyNullable = typeSymbol is INamedTypeSymbol { ConstructedFrom.SpecialType: SpecialType.System_Nullable_T };
            if (!isAlreadyNullable)
            {
                globalType += "?";
            }
        }

        return globalType;
    }

    private static string GetMemberSignature(ISymbol member)
    {
        if (member is IMethodSymbol method)
        {
            string parameters = string.Join(",", method.Parameters.Select(p => p.Type.ToString()));
            return $"{method.Name}({parameters})";
        }

        return member.Name;
    }

    private static string GetNamespace(TypeDeclarationSyntax typeDeclaration)
    {
        string namespaceName = string.Empty;
        SyntaxNode? potentialNamespaceParent = typeDeclaration.Parent;

        while (potentialNamespaceParent is not null                       &&
               potentialNamespaceParent is not NamespaceDeclarationSyntax &&
               potentialNamespaceParent is not FileScopedNamespaceDeclarationSyntax)
        {
            potentialNamespaceParent = potentialNamespaceParent.Parent;
        }

        if (potentialNamespaceParent is BaseNamespaceDeclarationSyntax namespaceParent)
        {
            namespaceName = namespaceParent.Name.ToString();
        }

        return namespaceName;
    }
}